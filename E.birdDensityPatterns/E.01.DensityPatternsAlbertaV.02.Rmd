---
title: "Bird Density Patterns"
author: "Lionel Leston and Nicole Barker"
output:
  word_document:
    reference_docx: ../RmdStyles/ReportFormat_1.docx
  html_document: default
editor_options: 
  chunk_output_type: console
---


**Objective: Summarize how observed bird density varies across forest attributes**

**Desired result**: A mean observed density for each forest stand type that has at least one point count survey

We need to convert observed Counts to predicted Density only to correct for survey method and detectability. We can't describe patterns in counts because it is confounded with different contributed datasets. We can't do a simple count/area calculation because survey methods differ. Fortunately BAM's QPAD offsets correct for survey method (duration, count radius)

**Approach**

* Build a cell-means model (no intercept), with forest stand type (ForID) as the sole predictor. TOTA (QPAD-derived offsets for total species) is included as an offset to correct for method. 
    * Poisson GLM: Count + offset ~ ForID
        * Forest stand type as predictor
        * Count as response variable
        * TOTA offset as offset 
* Plot ForID means as a function of forest attributes to show how bird density varies across forest attributes. 

**Assumptions:** A number of assumptions are made, as a result of the unbalanced sample 'design' within the BAM dataset. 

Consider this: 
* Multiple surveys within a year for a given location (PKEY within SS:YEAR)
* Multiple years for a given location (YEAR per SS)
* Variable numbers of point count survey stations for a given stand (SS per ObjectID)
* Multiple examples of stands on the landscape for a given stand type (ObjectID for ForestId)

If we treat PKEY as the sampling unit, we see a) multiple sources of variation being crammed into one analysis; and b) pseudoreplication since some stands and stand types will have way more replicates (i.e., bird surveys) than others. 

Can we accommodate this nested structure when calculating summary statistics, figures, etc?

Some possible options

1. Treat all PKEY as independent. 
2. Subsample: Take one PKEY per SS. 
3. Aggregate to stand: Average per stand across SS/PKEY becomes the DV
4. Aggregate to stand type: Average per ForestID across SS/PKEY becomes the DV. 
5. Bootstrapped subsample: Take multiple weighted samples of data. SS is unit of replication. We choose a maximum number of SS per stand and randomly select from the available SS if there's more than that number. Within an SS, we choose a single PKEY. 

This current script is a **DEMONSTRATION** only. Lionel and Nicole have not discussed which approach to take. So the below script uses all PKEYs, treating them as independent replicates. There is some pseudoreplication in that survey locations (SSs) are represented more than once. The dataset is reduced to one bird density value per ForestID (stand type) for plotting across forest attributes. 


``` {r setup, echo=F, message=F, warning=F}
require(knitr)
opts_knit$set(root.dir = '..')
knitr::opts_chunk$set(
  fig.path = "figures/"
)
rm(list=ls())
getwd()
```

``` {r}
path<-"C:/Users/Lionel/Documents/MITACS ACCELERATE FELLOWSHIP/Incidental Take Risk Ranking Matrix for Westfraser/Git Repository/My Repos/BC_Risk_Matrix/"
source(paste0(path,"Rfunctions/UsefulFunctions.R")) 
```


#### Method: Poisson GLM 

* Build a cell-means model (no intercept), with forest stand type (ForestID) as the sole predictor. Correcting counts to density with QPAD offsets for "TOTAL species"
        * Forest stand type as predictor
        * Count as response variable
        * TOTA offset as offset 

Count + offset ~ ForestID

#### Dataset requirements

1. mastermatrix
2. ranks
3. bird observations
4. QPAD offsets

#### Data subset:

Those stand types that were sampled by at least one bird point count survey.

## Step 1. Load data

####1. mastermatrix

Contains all possible forest stand type combinations, based on factorial combination of all levels of all 4 attributes. The combination of forest attributes is the unique ForID for a stand type.

```{r load.matrixTemplate, echo=T, eval=T}
load(paste0(path,"RDataFiles/AlbertaMastermatrix.RData"))
AlbertaMastermatrix$ForID.qs <- AlbertaMastermatrix$ForestID
AlbertaMastermatrix$ForID <- as.character(AlbertaMastermatrix$ForestID)
kable(head(AlbertaMastermatrix, 10), row.names = F)


#Save full names for each of these variables before abbreviating names
#for graphs in original variable. Then we have the option of using #either full or abbreviated names in different graphs
AlbertaMastermatrix$standtype.full<-AlbertaMastermatrix$standtype.name
AlbertaMastermatrix$subregion.full<-AlbertaMastermatrix$subregion.name
AlbertaMastermatrix$tpr.full<-AlbertaMastermatrix$tpr.name
AlbertaMastermatrix$ageclass.full<-AlbertaMastermatrix$ageclass

#Now create abbreviations for maps
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-conifer", "MW-C", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-decid", "MW-D", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-decidPl", "MW-D-Pl", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-decidSb", "MW-D-Sb", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-decidSw", "MW-D-Sw", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-Pl", "MW-Pl", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-Sb", "MW-Sb", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Mixedwood-Sw", "MW-Sw", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PureBlackSpruce", "Sb", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PureConifer-Allcon", "C-all", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PureConifer-AllCon", "C-all", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PureConifer-Pl", "C-Pl", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PureConifer-Sx", "C-Sx", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PureHardwood", "D", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PurePine", "P", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("PureWhiteSpruce", "Sw", AlbertaMastermatrix$standtype.name)
AlbertaMastermatrix$standtype.name<-gsub("Unidentified", "UnID", AlbertaMastermatrix$standtype.name)

AlbertaMastermatrix$subregion.name<-gsub("Alpine-Subalpine","AlpSub", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Athabasca Plain ALPAC","AthPla", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Boreal Subarctic","BorSub", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Central Mixedwood","CenMix", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Dry Mixedwood","DryMix", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Northern Mixedwood","NorMix", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Lower Boreal Highlands","LowBorHig", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Lower Foothills","LowFoo", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Upper Boreal Highlands","UppBorHig", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Upper Foothills","UppFoo", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Unidentified","UnID", AlbertaMastermatrix$subregion.name)
AlbertaMastermatrix$subregion.name<-gsub("Montane","Mon", AlbertaMastermatrix$subregion.name)

AlbertaMastermatrix$ageclass<-gsub("a.Age 0-2 Y","0-2y",AlbertaMastermatrix$ageclass)
AlbertaMastermatrix$ageclass<-gsub("b.Age 3-30 Y","a.3-30y",AlbertaMastermatrix$ageclass)
AlbertaMastermatrix$ageclass<-gsub("c.Age 31-60 Y","b.31-60y",AlbertaMastermatrix$ageclass)
AlbertaMastermatrix$ageclass<-gsub("d.Age 61-80 Y","c.61-80y",AlbertaMastermatrix$ageclass)
AlbertaMastermatrix$ageclass<-gsub("e.Age 81-100 Y","d.81-100y",AlbertaMastermatrix$ageclass)
AlbertaMastermatrix$ageclass<-gsub("f.Age 101-140 Y","e.101-140y",AlbertaMastermatrix$ageclass)
AlbertaMastermatrix$ageclass<-gsub("g.Age 141+","f.>140y",AlbertaMastermatrix$ageclass)

AlbertaMastermatrix$tpr.name<-gsub("Unproductive","a.Unproductive",AlbertaMastermatrix$tpr.name)
AlbertaMastermatrix$tpr.name<-gsub("Fair","b.Fair",AlbertaMastermatrix$tpr.name)
AlbertaMastermatrix$tpr.name<-gsub("Medium","c.Medium",AlbertaMastermatrix$tpr.name)
AlbertaMastermatrix$tpr.name<-gsub("Good","d.Good",AlbertaMastermatrix$tpr.name)

AlbertaMastermatrix<-AlbertaMastermatrix[!AlbertaMastermatrix$subregion.name=="UnID",]
AlbertaMastermatrix<-AlbertaMastermatrix[!AlbertaMastermatrix$standtype.name=="UnID",]

AlbertaMatrix.qs <- AlbertaMastermatrix
```

####2. ranks

Contains stand ranks assigned to ForID. Note that ranks were previously quality-checked. These are the final ranks. 

``` {r}
ranks <- read.csv(paste0(path,"rawData/AlbertaForID_Ranks_final_long.csv"), head=T)
ranks$ForestID.qs <- ranks$ForestID
ranks$ForestID <- as.character(ranks$ForestID)
ranks$FinalRank[ranks$FinalRank==999]<-NA
ranks$FinalRank[ranks$FinalRank==0]<-NA
ranks<-ranks[!is.na(ranks$FinalRank),]
ranks.qs <- ranks

kable(t(table(ranks$FinalRank)))
```

As seen above, this file contained text-based ranks that won't work in a GLM, and 999's and 0's for some polygons missing 1 or more environmental variables. All of these NA's were removed.

``` {r}
ranks$FinalRank <- as.numeric(as.character(ranks$FinalRank))
kable(head(ranks, 10))
kable(t(table(ranks$FinalRank)))
```
The ForestID column in "ranks" needs to be formatted to match up with the ForestID column in "AlbertaMastermatrix".

``` {r}
ranks$ForestID<-gsub("DryMixedwood", "Dry Mixedwood", ranks$ForestID)
ranks$ForestID<-gsub("AthabascaPlainALPAC", "Athabasca Plain ALPAC", ranks$ForestID)
ranks$ForestID<-gsub("BorealSubarctic", "Boreal Subarctic", ranks$ForestID)
ranks$ForestID<-gsub("CentralMixedwood", "Central Mixedwood", ranks$ForestID)
ranks$ForestID<-gsub("LowerBorealHighlands", "Lower Boreal Highlands", ranks$ForestID)
ranks$ForestID<-gsub("LowerFoothills", "Lower Foothills", ranks$ForestID)
ranks$ForestID<-gsub("NorthernMixedwood", "Northern Mixedwood", ranks$ForestID)
ranks$ForestID<-gsub("UpperBorealHighlands", "Upper Boreal Highlands", ranks$ForestID)
ranks$ForestID<-gsub("UpperFoothills", "Upper Foothills", ranks$ForestID)
ranks$ForestID<-gsub("_", "-", ranks$ForestID)
ranks$ForestID<-gsub("pure", "Pure", ranks$ForestID)
ranks$ForestID<-gsub("allcon", "Allcon", ranks$ForestID)

ranks$ForestID<-gsub("\\Y.G","Y.Good", ranks$ForestID)
ranks$ForestID<-gsub("\\Y.M","Y.Medium", ranks$ForestID)
ranks$ForestID<-gsub("\\Y.F","Y.Fair", ranks$ForestID)
ranks$ForestID<-gsub("\\Y.U","Y.Unproductive", ranks$ForestID)

ranks$ForestID<-gsub("\\NA.G","NA.Good", ranks$ForestID)
ranks$ForestID<-gsub("\\NA.M","NA.Medium", ranks$ForestID)
ranks$ForestID<-gsub("\\NA.F","NA.Fair", ranks$ForestID)
ranks$ForestID<-gsub("\\NA.U","NA.Unproductive", ranks$ForestID)

ranks$ForestID<-gsub("\\+.G","+.Good", ranks$ForestID)
ranks$ForestID<-gsub("\\+.M","+.Medium", ranks$ForestID)
ranks$ForestID<-gsub("\\+.F","+.Fair", ranks$ForestID)
ranks$ForestID<-gsub("\\+.U","+.Unproductive", ranks$ForestID)

ranks$ForestID<-gsub("\\NA.","Unidentified.", ranks$ForestID)
ranks$ForestID<-gsub("\\.0.",".Unidentified.", ranks$ForestID)

write.csv(ranks, file="ranksS24.csv")#data check

```

####3. bird observations

Bird data from BAM avian dataset available for sampled forest stands:

1) SS: sampling location; point count location within a forest stand
2) PKEY: unique survey identity
3) Count: sum of birds per survey (PKEY)
4) ForID: unique forst stand type within which the SS is located.

For Alberta, I have point count data (counts and QPAD offsets for individual species, which can be used to get Count and TOTA).

I extracted raster data for these point count locations in May, 2018
and can use this information to get ForestID for each point count.

I will merge the count data and data extracted from rasters via the SS
variable to create the file "AlbertaTOTALcount.per.PKEY.withForestID.RData"

```{r merge.pointcountloc.data, echo=T, eval=T}
countdata<-read.csv(paste0(path,"RDataFiles/AlbertaPointCountsAndOffsetsfromhabitatcategoriesAug16.csv"),header=T)#count, offset, habitat, footprint data per PKEY and SS (as of Aug.16, 2018)
extractedtocount<-read.csv(paste0(path,"RDataFiles/AlbertapointsCdatacheckMay23.csv"),header=T)#ForestID data extracted to SS back in May 2018
extractedtocount<-extractedtocount[,c("SS","ForestID")]#minimize variables from "extractedtocount" that we merge with "countdata"
merged2gether<-merge(countdata, extractedtocount, by=c("SS"), all=T)
write.csv(merged2gether, file=paste0(path,"RDataFiles/merged2gether.csv"))
#now reformat ForestID to match formatting in AlbertaMastermatrix
merged2gether$ForestID<-gsub("DryMixedwood", "Dry Mixedwood", merged2gether$ForestID)
merged2gether$ForestID<-gsub("AthabascaPlainALPAC", "Athabasca Plain ALPAC", merged2gether$ForestID)
merged2gether$ForestID<-gsub("BorealSubarctic", "Boreal Subarctic", merged2gether$ForestID)
merged2gether$ForestID<-gsub("CentralMixedwood", "Central Mixedwood", merged2gether$ForestID)
merged2gether$ForestID<-gsub("LowerBorealHighlands", "Lower Boreal Highlands", merged2gether$ForestID)
merged2gether$ForestID<-gsub("LowerFoothills", "Lower Foothills", merged2gether$ForestID)
merged2gether$ForestID<-gsub("NorthernMixedwood", "Northern Mixedwood", merged2gether$ForestID)
merged2gether$ForestID<-gsub("UpperBorealHighlands", "Upper Boreal Highlands", merged2gether$ForestID)
merged2gether$ForestID<-gsub("UpperFoothills", "Upper Foothills", merged2gether$ForestID)
merged2gether$ForestID<-gsub("\\.0.", ".Unidentified.", merged2gether$ForestID)
merged2gether$ForestID<-gsub("_", "-", merged2gether$ForestID)
merged2gether$ForestID<-gsub("pure", "Pure", merged2gether$ForestID)
merged2gether$ForestID<-gsub("allcon", "Allcon", merged2gether$ForestID)
#after transforming ".0." to ".Unidentified." and "pure" to "Pure"
merged2gether$ForestID<-gsub("0.Pure", "Unidentified.Pure", merged2gether$ForestID, fixed=T)
merged2gether$ForestID<-gsub("0.Mixed", "Unidentified.Mixed", merged2gether$ForestID, fixed=T)
save(merged2gether, file=paste0(path,"RDataFiles/AlbertaCounts.RData"))

```

I will then load the data into R if it is not there already
```{r load.pointcountloc.data, echo=T, eval=T}
load(paste0(path,"RDataFiles/AlbertaCounts.RData"))
colnames(merged2gether)
nrow(merged2gether)#36612 observations
length(unique(merged2gether))#571 variables
```

For some reason, the dataset has replicate rows for a given PKEY. I must eliminate them. 

``` {r}
birds <- merged2gether[!duplicated(merged2gether),]
nrow(birds)#23922
str(birds[,77:247])#begins with first species, ALFL
str(birds[,245:247])#ends with last species, YRWA
birds$Count<-rowSums(birds[,77:247])
birds <- birds[c("ForestID", "PKEY", "Count")]

pkey_pieces <- data.frame(str_split_fixed(birds$PKEY, ":", 5))
colnames(pkey_pieces) <- c("PCODE", "SITE", "STN", "YY", "ROUND")
pkey_pieces$YYYY <- substr(as.Date(pkey_pieces$YY, "%y"), 1,4)
pkey_pieces$SS <- paste(pkey_pieces$PCODE, pkey_pieces$SITE, pkey_pieces$STN, sep=":")

totalBirds <- cbind(birds, pkey_pieces)
totalBirds$ForestID <- as.character(totalBirds$ForestID)

kable(rbind(head(totalBirds, 10), tail(totalBirds, 10)), row.names = F)
```


####4. QPAD offsets

Offsets developed using QPAD approach, for "total species". Corrects for survey methodology but not individual species' singing rates or EDRs. Treats all species as one highly-variable species. 

In contrast to the BC data, the offsets are already in the point count file previously loaded into R.


``` {r}
load(paste0(path,"RDataFiles/AlbertaTOTAoffsets-v3_2018-03-02.RData"))
load(paste0(path,"RDataFiles/AlbertaTOTAoffsets-v3data_2018-03-02.RData"))
qs.off <- OFF

kable(head(OFF, 10))

OFF <- as.data.frame(OFF)
OFF$PKEY <- row.names(OFF)
kable(head(OFF, 10), row.names=F)

```

####5. Previously aggregated rank means

These summaries of average rank across various combinations of forest attribute were generated in D.01.RankPatterns.Rmd

``` {r}
load(paste0(path,"RDataFiles/AlbertasummarizedRanks.RData"))
```

## Step 2. Combine datasets and switch column classes as necessary

#### Associate offset with PKEY
``` {r}
totalBirds <- merge(totalBirds, OFF, by="PKEY", all.x=T) # merge by PKEY; keep only those PKEY in bird dataset.
```

#### Associate rank with ForID
``` {r}
mastermatrix <- merge(AlbertaMastermatrix, ranks, by="ForestID", all=T) # merge by ForID. Keep all ForIDs for now (even unranked)
```

#### Associate bird data with ForID
``` {r}
totalBirds <- merge(totalBirds, mastermatrix[c("ForestID", "subregion.name", "subregion.full", "standtype.name", "standtype.full", "ageclass", "ageclass.full", "tpr.name", "tpr.full", "FinalRank")], by="ForestID", all.x=T) # merge by ForestID. Keep only sampled ForestIDs (i.e., those with survey data)
totalBirds <- totalBirds[c("ForestID", "subregion.name", "subregion.full", "standtype.name", "standtype.full", "ageclass", "ageclass.full", "tpr.name", "tpr.full", "SS", "PKEY", "Count", "TOTA", "FinalRank")]

kable(head(totalBirds, 20), row.names=F)
```

* Number of rows in resultant data.frame: `r nrow(totalBirds)`
* Number of unique PKEY: `r length(unique(totalBirds$PKEY))`
* Number of unique ForestID: `r length(unique(totalBirds$ForestID))`

#### Clean up and switch classes as necessary

``` {r}
totalBirds<-totalBirds[!is.na(totalBirds$ageclass),]
totalBirds<-totalBirds[!is.na(totalBirds$tpr.name),]
totalBirds<-totalBirds[!is.na(totalBirds$standtype.name),]
totalBirds<-totalBirds[!is.na(totalBirds$subregion.name),]


unique(totalBirds$ageclass) # already an ordered factor
#7 levels(totalBirds$ForAge) <- c("3-30 yrs", "31-80 yrs", "81-120 yrs", "121-250 yrs", ">250 yrs")
#unique(totalBirds$ForAge) # already an ordered factor

unique(totalBirds$tpr.name) # already an ordered factor
#4 levels(totalBirds$ForHt) <- c("<10.5 m", "10.5-19.4 m", "19.5-28.4 m", "> 28.5 m")
#unique(totalBirds$ForHt) # already an ordered factor

totalBirds$subregion.name <- factor(totalBirds$subregion.name) # eliminates missing subregion.name levels
unique(totalBirds$subregion.name)#11 levels
totalBirds<-totalBirds[!totalBirds$subregion.name=="UnID",]

totalBirds$standtype.name <- factor(totalBirds$standtype.name) # eliminates missing speciesgroup levels
unique(totalBirds$standtype.name)#16 levels
totalBirds<-totalBirds[!totalBirds$standtype.name=="UnID",]

```

There are `r length(unique(totalBirds$ForID))` sampled forest stand types going into this analysis. 

#### Save pre-cleaned dataset

``` {r}
save(totalBirds, file=paste0(path,"RDataFiles/AlbertatotalBirds_clean.RData"))
```

## Step 3. Calculate mean density per ForestID, rather than count 

If we want to plot anything to interpret our results, we can't just plot count beause it is not corrected for method/detectability. 

So here we're just calculating the mean bird density per ForID (forest stand type).

Forest stand type is a factor with `r length(unique(totalBirds$ForID))` levels

``` {r}
load(paste0(path,"RDataFiles/AlbertatotalBirds_clean.RData"))
if ('Albertafit.dens.forid_tot.RData' %in% dir(paste0(path,"RDataFiles"))) {
  load(paste0(path,"RDataFiles/Albertafit.dens.forid_tot.RData")) # loads the saved results if it's already run and saved
}


if (exists("Albertafit.dens.forid_tot")==FALSE) { #conditional statement; won't run if the file was already loaded from RData
  totalBirds<-totalBirds[!is.na(totalBirds$Count),] #remove NA values
  totalBirds<-totalBirds[!is.na(totalBirds$ForestID),] #remove NA values
  newdat<-totalBirds   #define test/prediction data up here BEFORE model is run, so that new ForestID levels are not generated in the prediction dataset. That would occur if we ran the model on totalBirds without removing ForestIDs that will not be used in the model, but those ForestIDs occur in the prediction dataset. Then even if we remove those levels from the prediction dataset, factor levels will be set up differently than they were in the model training data.
  newdat$TOTA<-0   #set offsets to zero to calculate predicted density rather than predicted count

  fit.dens.forid_tot <- glm(Count ~ ForestID-1, family=poisson, data=totalBirds, offset=TOTA)  # run if not already run and saved
  save(fit.dens.forid_tot, file=paste0(path,"RDataFiles/Albertafit.dens.forid_tot.RData")) # save it so i don't need to run again. 
}

```

#### Prediction: Estimate the number of birds in each forest stand type, based on the model. 

Only predicts to the forest stands we sampled. `r length(unique(totalBirds$ForID))` unique stand types.
Basically just takes the mean of all samples within a forest stand type and adjusts by the offset. All stands of the same type will have the same predicted bird density. No environmental covariates in the above model.

``` {r}
totalBirds$PredDens_ForID <- predict(fit.dens.forid_tot, newdata=newdat, type="response")

```

##### Double-check that these predictions make sense. 

Expectation: All point counts within the same forest stand type should have the same expected density, if I understand this analysis correctly. 

``` {r}
testset <- totalBirds[totalBirds$ForestID %in% "Dry Mixedwood.PureHardwood.Age 61-80 Y.Good",]
#60 observations
unique(testset$PredDens_ForID)#9.067884
unique(testset$Count)#16 14 13  7  3 15 10 17 12 11  9  8  6 21
testset2 <- totalBirds[totalBirds$ForestID %in% "Central Mixedwood.Mixedwood-decidSw.Age 141+.Medium",]
#14 observations
unique(testset2$PredDens_ForID)#6.779119
unique(testset2$Count)#6 11 9 3 15
```

Expectation is true for those example Forest stand types, despite their observed counts being different. 


# Plot Patterns: Visualize relationships between age/height and bird density (in sampled stands)

### Subset dataset to a single density value per forest stand type (ForID)

``` {r}
totalBirds.all <- totalBirds
totalBirds.all <- totalBirds.all[c("ForestID", "subregion.name", "standtype.name", "ageclass", "tpr.name", "FinalRank", "PredDens_ForID")]
totalBirds.sdv <- totalBirds.all[!duplicated(totalBirds.all),]
dens_per_ForID <- totalBirds.sdv
save(dens_per_ForID, file=paste0(path,"RDataFiles/AlbertatotalBirds_withpreds.RData"))
```

#### Density as a function of rank 

``` {r}
totalBirds.sdv$FinalRank[totalBirds.sdv$FinalRank==999]<-"NA"
totalBirds.sdv$FinalRank[totalBirds.sdv$FinalRank==0]<-"NA"
totalBirds.sdv<-totalBirds.sdv[!is.na(totalBirds.sdv$FinalRank),]
totalBirds.sdv$FinalRank <-as.numeric(totalBirds.sdv$FinalRank)
ggplot(totalBirds.sdv, aes(x=as.factor(FinalRank), y=PredDens_ForID, group=as.factor(FinalRank), fill=as.factor(FinalRank))) + geom_boxplot() + xlab("Rank") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + guides(fill=FALSE) + scale_fill_manual(values=palrank)

ggplot(totalBirds.sdv, aes(x=as.factor(FinalRank), y=PredDens_ForID, group=as.factor(FinalRank), col=as.factor(FinalRank), fill=as.factor(FinalRank))) + geom_violin() + xlab("Rank") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + guides(col=FALSE, fill=FALSE) + scale_fill_manual(values=palrank) + scale_colour_manual(values=palrank)
```

#### Bird density as a function of timber productivity rating and age 
Across all subregion and stand types.
Boxplot and violin plot show the same information. 
Labelled points show the mean rank across stands of that combination of age and timber productivity. 

##### Create fake data to help with plotting

Some combinations of forest attributes were not sampled. When plotting box plots, the box width varies when certain categories don't have data. 

The [solution](https://stackoverflow.com/questions/15367762/include-space-for-missing-factor-level-used-in-fill-aesthetics-in-geom-boxplot) is to create fake data for the combination of factors for which data is currently missing. The data needs to be outside the plotting range of real data. 

First we need to identify which combinations of Forest age and TPR have missing values. 
Then we create fake data for those combinations. Needs to have the same columns as the data.frame I'll be using to plot (in this case, totalBirds).

``` {r}

mastermatrix<-mastermatrix[!is.na(mastermatrix$ageclass),]
mastermatrix<-mastermatrix[!is.na(mastermatrix$tpr.name),]
mastermatrix<-mastermatrix[!is.na(mastermatrix$standtype.name),]
mastermatrix<-mastermatrix[!is.na(mastermatrix$subregion.name),]


agetprcombos.possible <- unique(paste(mastermatrix$ageclass, mastermatrix$tpr.name, sep="_and_"))
agetprcombos.sampled <- unique(paste(totalBirds$ageclass, totalBirds$tpr.name, sep="_and_"))
agetprcombos.missing <- agetprcombos.possible[!agetprcombos.possible %in% agetprcombos.sampled]

dat2 <- data.frame(str_split_fixed(agetprcombos.missing, "_and_", 2))  # create dataframe for ForestID with no bird data
colnames(dat2) <- c("ageclass", "tpr.name")
dat4 <- data.frame(ForestID=rep(-999, times=nrow(dat2)), subregion.name=rep(unique(totalBirds$subregion.name)[1], times=nrow(dat2)), standtype.name=rep(unique(totalBirds$standtype.name)[1], times=nrow(dat2)), ageclass=dat2$ageclass, tpr.name=dat2$tpr.name, FinalRank=rep(-999, times=nrow(dat2)), PredDens_ForID=rep(-999, times=nrow(dat2)))   # create fake data for Count, FinalRank, and PredDens_ForID

test <- rbind(totalBirds[colnames(dat4)], dat4) # combine real data with fake data
```



``` {r Fig.BirdDens_AgeHeight, fig.height=6, fig.width=7, dpi=150, eval=T}
ggplot(test, aes(x=ageclass, y=PredDens_ForID, fill=tpr.name)) + geom_boxplot(na.rm=FALSE) + xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 9)) + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") 

ggplot(test, aes(x=ageclass, y=PredDens_ForID, fill=tpr.name)) + geom_boxplot(na.rm=FALSE) + xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme5 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 8)) + geom_point(data=rank.aggregates[[1]], aes(x=ageclass, y=FinalRank+19, col=tpr.name), position=position_dodge(width=.75), size=4, show.legend = F) + geom_text(data=rank.aggregates[[1]], aes(x=ageclass, y=FinalRank+20, label=round(FinalRank,1)), position=position_dodge(width=0.75), size=3.1)  + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") + geom_hline(yintercept=20) + geom_text(aes(x=2, y=26.5), label="Rank from Matrix", col="black", size=5)

ggplot(totalBirds, aes(x=ageclass, y=PredDens_ForID, fill=tpr.name)) + geom_violin() + xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") 
```


``` {r}
rm(test, agetprcombos.missing, agetprcombos.possible, agetprcombos.sampled)
```

### Subregion-specific relationships (formerly BEC)

Depict pattern in bird density as a function of forest age and TPR, separated by different subregions.

##### Create fake data to help with plotting

``` {r}
agetprsubcombos.possible <- unique(paste(mastermatrix$ageclass, mastermatrix$tpr.name, mastermatrix$subregion.name, sep="_and_"))
agetprsubcombos.sampled <- unique(paste(totalBirds$ageclass, totalBirds$tpr.name, totalBirds$subregion.name, sep="_and_"))
agetprsubcombos.missing <- agetprsubcombos.possible[!agetprsubcombos.possible %in% agetprsubcombos.sampled]

dat2 <- data.frame(str_split_fixed(agetprsubcombos.missing, "_and_", 3))  # create dataframe for ForID with no bird data
colnames(dat2) <- c("ageclass", "tpr.name", "subregion.name")
dat4 <- data.frame(ForestID=rep(-999, times=nrow(dat2)), subregion.name=dat2$subregion.name, standtype.name=rep(unique(totalBirds$standtype.name)[1], times=nrow(dat2)), ageclass=dat2$ageclass, tpr.name=dat2$tpr.name, FinalRank=rep(-999, times=nrow(dat2)), PredDens_ForID=rep(-999, times=nrow(dat2)))   # create fake data for Count, FinalRank, and PredDens_ForID

test <- rbind(totalBirds[colnames(dat4)], dat4) # combine real data with fake data
Ord1 <- order(test$subregion.name)
test <- test[with(test, order(subregion.name)), ]
#sorts dataframe "test" by values in the variable "subregion.name" so that data are in same order by subregion as the dataset in the other part of the split panel plot
#dat2 and dat4 subregions are ordered alphabetically
#test$subregion is not and it fails to sort. WHY????

rm(dat2, dat4)

# fake data for rank aggregates as well
agetprsubrank <- rank.aggregates[[2]]
agetprsubcombos.ranked <- unique(paste(agetprsubrank$ageclass, agetprsubrank$tpr.name, agetprsubrank$subregion.name, sep="_and_"))
agetprsubcombos.missing <- agetprsubcombos.possible[!agetprsubcombos.possible %in% agetprsubcombos.ranked]

rdat2 <- data.frame(str_split_fixed(agetprsubcombos.missing, "_and_", 3))  # create dataframe for unranked combinations
colnames(rdat2) <- c("ageclass", "tpr.name", "subregion.name")

rdat4 <- data.frame(ageclass=rdat2$ageclass, tpr.name=rdat2$tpr.name, subregion.name=rdat2$subregion.name, FinalRank=rep(-999, times=nrow(rdat2)))   # create fake data for other columns in agetprsubrank

rankagg.agetprsub <- rbind(agetprsubrank[colnames(rdat4)], rdat4) # combine real data with fake data
```


``` {r Fig.BirdDens_AgeHeightBEC, fig.height=6, fig.width=7, dpi=150, eval=T}
test$subregion.name<-as.factor(test$subregion.name)
tota.sub <- split(test, test$subregion.name)
rank.agg.sub <- split(rankagg.agetprsub,rankagg.agetprsub$subregion.name)

lapply(1:length(tota.sub), function(i) {
  ggplot(tota.sub[[i]], aes(x=ageclass, y=PredDens_ForID, fill=tpr.name)) + geom_boxplot() + facet_wrap(~subregion.name) + xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 9))   + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") 

    ggplot(tota.sub[[i]], aes(x=ageclass, y=PredDens_ForID, fill=tpr.name)) + geom_boxplot() + facet_wrap(~subregion.name) + xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme5 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 8)) + geom_point(data=rank.agg.sub[[i]], aes(x=ageclass, y=FinalRank+20, col=tpr.name), position=position_dodge(width=.75), size=4, show.legend = F) + geom_text(data=rank.agg.sub[[i]], aes(x=ageclass, y=FinalRank+21, label=round(FinalRank,1)), position=position_dodge(width=0.75), size=3.1)  + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") + geom_hline(yintercept=20) + geom_text(aes(x=1.05, y=26.5), label="Rank from Matrix", col="black", size=5)
})
  
lapply(tota.sub, function(x) {
  ggplot(x, aes(x=ageclass, y=PredDens_ForID, col=tpr.name, fill=tpr.name)) + geom_violin()  + facet_wrap(~subregion.name)+ xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") 
})
```

``` {r}
rm(test, agetprsubcombos.missing, agetprsubcombos.possible, agetprsubcombos.sampled, tota.sub, rankagg.agetprsub, rank.agg.sub)
```


### Patterns for different stand types 

Depict pattern in bird density as a function of forest age and timber productivity rating, separated by different stand types

##### Create fake data to help with plotting

``` {r}
agetprstandcombos.possible <- unique(paste(mastermatrix$ageclass, mastermatrix$tpr.name, mastermatrix$standtype.name, sep="_and_"))
agetprstandcombos.sampled <- unique(paste(totalBirds$ageclass, totalBirds$tpr.name, totalBirds$standtype.name, sep="_and_"))
agetprstandcombos.missing <- agetprstandcombos.possible[!agetprstandcombos.possible %in% agetprstandcombos.sampled]

dat2 <- data.frame(str_split_fixed(agetprstandcombos.missing, "_and_", 3))  # create dataframe for ForestID with no bird data
colnames(dat2) <- c("ageclass", "tpr.name", "standtype.name")

dat4 <- data.frame(ForestID=rep(-999, times=nrow(dat2)), subregion.name=rep(unique(totalBirds$subregion.name)[1], times=nrow(dat2)), standtype.name=dat2$standtype.name, ageclass=dat2$ageclass, tpr.name=dat2$tpr.name, FinalRank=rep(-999, times=nrow(dat2)), PredDens_ForID=rep(-999, times=nrow(dat2)))   # create fake data for Count, FinalRank, and PredDens_ForestID

test <- rbind(totalBirds[colnames(dat4)], dat4) # combine real data with fake data
rm(dat2,dat4)

# fake data for rank aggregates as well
agetprstandrank <- rank.aggregates[[3]]
agetprstandcombos.ranked <- unique(paste(agetprstandrank$ageclass, agetprstandrank$tpr.name, agetprstandrank$subregion.name, sep="_and_"))
agetprstandcombos.missing <- agetprstandcombos.possible[!agetprstandcombos.possible %in% agetprstandcombos.ranked]

rdat2 <- data.frame(str_split_fixed(agetprstandcombos.missing, "_and_", 3))  # create dataframe for unranked combinations
colnames(rdat2) <- c("ageclass", "tpr.name", "standtype.name")

rdat4 <- data.frame(ageclass=rdat2$ageclass, tpr.name=rdat2$tpr.name, standtype.name=rdat2$standtype.name, FinalRank=rep(-999, times=nrow(rdat2)))   # create fake data for other columns in agehtbecrank

rankagg.agetprstand <- rbind(agetprstandrank[colnames(rdat4)], rdat4) # combine real data with fake data
```

``` {r Fig.BirdDens_AgeHeightSpeciesGroup, fig.height=6, fig.width=7, dpi=150, eval=T}
tota.stand <- split(test, test$standtype.name)
rank.agg.stand <- split(rankagg.agetprstand, rankagg.agetprstand$standtype.name)


lapply(names(tota.stand), function(i) {
  ggplot(tota.stand[[i]], aes(x=ageclass, y=PredDens_ForID, fill=tpr.name)) + geom_boxplot() + facet_wrap(~standtype.name) + xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 9))   + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") 

    ggplot(tota.stand[[i]], aes(x=ageclass, y=PredDens_ForID, fill=tpr.name)) + geom_boxplot() + facet_wrap(~standtype.name) + xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme5 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 8)) + geom_point(data=rank.agg.stand[[i]], aes(x=ageclass, y=FinalRank+20, col=tpr.name), position=position_dodge(width=.75), size=4, show.legend = F) + geom_text(data=rank.agg.stand[[i]], aes(x=ageclass, y=FinalRank+21, label=round(FinalRank,1)), position=position_dodge(width=0.75), size=3.1)  + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") + geom_hline(yintercept=20) + geom_text(aes(x=1.5, y=25), label="Rank from Matrix", col="black", size=5)
})

lapply(tota.stand, function(x) {
  ggplot(x, aes(x=ageclass, y=PredDens_ForID, col=tpr.name, fill=tpr.name)) + geom_violin()  + facet_wrap(~standtype.name)+ xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme2  + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") 
})
```

``` {r}
rm(test, agetprstandcombos.missing, agetprstandcombos.possible, agetprstandcombos.sampled, tota.stand, rankagg.agetprstand, rank.agg.stand)
```


### Patterns for different combinations of subregions and stand types

##### Create fake data to help with plotting

``` {r}
forid.possible <- unique(paste(mastermatrix$ageclass, mastermatrix$tpr.name, mastermatrix$subregion.name, mastermatrix$standtype.name, sep="_and_"))
forid.sampled <- unique(paste(totalBirds$ageclass, totalBirds$tpr.name, totalBirds$subregion.name, totalBirds$standtype.name, sep="_and_"))
forid.missing <- forid.possible[!forid.possible %in% forid.sampled]

dat2 <- data.frame(str_split_fixed(forid.missing, "_and_", 4))  # create dataframe for ForID with no bird data
colnames(dat2) <- c("ageclass", "tpr.name", "subregion.name", "standtype.name")

dat4 <- data.frame(ForestID=rep(-999, times=nrow(dat2)), subregion.name=dat2$subregion.name, standtype.name=dat2$standtype.name, ageclass=dat2$ageclass, tpr.name=dat2$tpr.name, FinalRank=rep(-999, times=nrow(dat2)), PredDens_ForID=rep(-999, times=nrow(dat2)))   # create fake data for Count, FinalRank, and PredDens_ForID

test <- rbind(totalBirds[colnames(dat4)], dat4) # combine real data with fake data

```



``` {r, Fig.BirdDens_AgeHeightBECSpeciesGroup, fig.height=6, fig.width=7, dpi=150, eval=T}
test$sub.stand <- with(test, paste(subregion.name, standtype.name, sep="."))
tota.sub.stand <- split(test, test$sub.stand)

mastermatrix$sub.stand <- with(mastermatrix, paste(subregion.name, standtype.name, sep="."))
ranks.split <- split(mastermatrix, mastermatrix$sub.stand)

lapply(names(tota.sub.stand), function(i) {
  ggplot(tota.sub.stand[[i]], aes(x=ageclass, y=PredDens_ForID, fill=tpr.name, col=tpr.name, group=tpr.name)) + geom_point(size=3, position=position_dodge(width=0.8)) + facet_wrap(~sub.stand)+ xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme2 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 9))  + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") 
  
  ggplot(tota.sub.stand[[i]], aes(x=ageclass, y=PredDens_ForID, fill=tpr.name, group=tpr.name)) + geom_point(aes(col=tpr.name), size=3, position=position_dodge(width=0.8)) + facet_wrap(~sub.stand)+ xlab("Forest Age") + ylab("Mean Density per Forest Stand Type") + myfacettheme5 + coord_cartesian(ylim=range(totalBirds$PredDens_ForID) + c(-1, 8))  + geom_point(data=ranks.split[[i]], aes(x=ageclass, y=FinalRank+20, col=tpr.name), position=position_dodge(width=.75), size=4, show.legend = F) + geom_text(data=ranks.split[[i]], aes(x=ageclass, y=FinalRank+21, label=round(FinalRank,1)), position=position_dodge(width=0.75), size=3.1)  + scale_colour_manual(values=paltpr, name="Timber Productivity Rating") + scale_fill_manual(values=paltpr, name="Timber Productivity Rating") + geom_hline(yintercept=20) + geom_text(aes(x=1.5, y=25), label="Rank from Matrix", col="black", size=5)
})
  
```
